<!DOCTYPE html>
<html>
<head>
  <title>Aesthetic Cam with Server-Side Filters</title>
  <style>
    #canvasOutput, #serverFeed {
      border: 2px solid #444;
      border-radius: 12px;
      margin: 10px;
      width: 640px;
      height: 480px;
      background-color: #333; /* Background for when image is loading/failed */
    }
    .controls {
      margin-top: 10px;
      padding: 10px;
    }
    label {
        margin-right: 15px;
    }
    button {
        margin-right: 10px;
    }
  </style>
</head>
<body>

  <h2>Aesthetic Camera with Server-Side Filters + Vibrance</h2>

  <div>
    <video id="localVideo" playsinline muted style="display:none;"></video>

    <img id="serverFeed" src="{{ url_for('video_feed', glasses=glasses_initial, moustache=moustache_initial) }}" alt="Video Stream" width="640" height="480">

    <canvas id="canvasOutput" width="640" height="480" style="display: none;"></canvas>
    </div>

  <div class="controls">
    <label><input type="checkbox" id="toggleGlasses"> Glasses 🕶️</label>
    <label><input type="checkbox" id="toggleMoustache"> Moustache 🥸</label>
    <button id="startBtn">Start Recording ⏺️</button>
    <button id="stopBtn" disabled>Stop Recording ⏹️</button>
    <a id="downloadLink" style="display:none;" download="aesthetic-recording.webm">Download Video 💾</a>
  </div>

  <script>
    const localVideo = document.getElementById('localVideo');
    const serverFeedImg = document.getElementById('serverFeed');
    const canvasOutput = document.getElementById('canvasOutput'); // Canvas is used for recording
    const ctx = canvasOutput.getContext('2d');

    const toggleGlasses = document.getElementById('toggleGlasses');
    const toggleMoustache = document.getElementById('toggleMoustache');

    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const downloadLink = document.getElementById('downloadLink');

    let localAudioStream;
    let recorder;
    let chunks = [];
    let animationFrameId;

    // Update the video feed URL based on checkboxes
    function updateVideoFeed() {
      const glassesOn = toggleGlasses.checked ? '1' : '0';
      const moustacheOn = toggleMoustache.checked ? '1' : '0';
      // Add a timestamp as a cache buster to ensure the browser requests the new stream
      serverFeedImg.src = `/video_feed?glasses=${glassesOn}&moustache=${moustacheOn}&t=${new Date().getTime()}`;
    }

    toggleGlasses.onchange = updateVideoFeed;
    toggleMoustache.onchange = updateVideoFeed;

    // Set initial checkbox states based on what server might have (if applicable)
    // For this setup, we assume they start unchecked matching glasses_initial='0', moustache_initial='0'
    // If you passed different initial values from Flask, you'd sync them here.
    // toggleGlasses.checked = {{ glasses_initial == '1' }}; // Example if you pass boolean
    // toggleMoustache.checked = {{ moustache_initial == '1' }};


    // Draw loop: takes the image from serverFeedImg and draws it to canvasOutput
    // This is primarily for the recording functionality.
    function drawLoop() {
      if (serverFeedImg.complete && serverFeedImg.naturalWidth > 0) {
        ctx.drawImage(serverFeedImg, 0, 0, canvasOutput.width, canvasOutput.height);
      }
      animationFrameId = requestAnimationFrame(drawLoop);
    }

    async function startLocalMediaAndDrawing() {
      try {
        localAudioStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
        localVideo.srcObject = localAudioStream; // Though hidden, good practice to assign

        // Start drawing the server feed to the canvas
        if (animationFrameId) cancelAnimationFrame(animationFrameId); // Clear previous loop if any
        drawLoop(); // Start drawing content from serverFeedImg to canvasOutput

      } catch (err) {
        console.error("Error accessing local audio.", err);
        alert("Could not access microphone. Recording will be video-only or fail. Please grant permissions.");
      }
    }

    // Initialize local media (for audio) and start drawing loop
    startLocalMediaAndDrawing();

    serverFeedImg.onload = () => {
      console.log("Video stream loaded/reloaded.");
      // The drawLoop will pick up the new content automatically.
    };

    serverFeedImg.onerror = () => {
      console.error("Error loading video stream from server.");
      ctx.clearRect(0,0, canvasOutput.width, canvasOutput.height); // Clear canvas
      ctx.fillStyle = '#555';
      ctx.fillRect(0, 0, canvasOutput.width, canvasOutput.height);
      ctx.fillStyle = 'white';
      ctx.textAlign = 'center';
      ctx.font = '20px Arial';
      ctx.fillText("Video Stream Error 😢", canvasOutput.width / 2, canvasOutput.height / 2);
      // Optionally, also update the serverFeedImg display itself or show a placeholder
    };

    startBtn.onclick = () => {
      if (!localAudioStream || localAudioStream.getAudioTracks().length === 0) {
        const confirmNoAudio = confirm("Audio stream not available. Record video only?");
        if (!confirmNoAudio) return;
      }

      const canvasStream = canvasOutput.captureStream(25); // 25 FPS from canvas

      if (localAudioStream && localAudioStream.getAudioTracks().length > 0) {
        const audioTrack = localAudioStream.getAudioTracks()[0];
        canvasStream.addTrack(audioTrack);
      } else {
        console.warn("Recording without audio track.");
      }

      // Ensure canvas has up-to-date content before starting recorder
      if (serverFeedImg.complete && serverFeedImg.naturalWidth > 0) {
        ctx.drawImage(serverFeedImg, 0, 0, canvasOutput.width, canvasOutput.height);
      }


      try {
        recorder = new MediaRecorder(canvasStream, { mimeType: 'video/webm; codecs=vp9,opus' }); // Specify codecs for better compatibility
      } catch (e) {
         try {
            console.warn("Failed to create MediaRecorder with vp9,opus. Trying default.");
            recorder = new MediaRecorder(canvasStream, { mimeType: 'video/webm' });
         } catch (e2) {
            alert("MediaRecorder API is not supported or failed to initialize. Cannot record.");
            console.error("MediaRecorder error:", e2);
            return;
         }
      }

      chunks = [];

      recorder.ondataavailable = e => {
        if (e.data.size > 0) {
          chunks.push(e.data);
        }
      };
      recorder.onstop = () => {
        if (chunks.length === 0) {
            console.warn("No data recorded.");
            downloadLink.style.display = 'none';
            alert("Recording failed or produced no data.");
            return;
        }
        const blob = new Blob(chunks, { type: 'video/webm' });
        downloadLink.href = URL.createObjectURL(blob);
        downloadLink.style.display = 'inline';
        chunks = []; // Clear chunks for next recording
      };

      recorder.start();
      startBtn.disabled = true;
      stopBtn.disabled = false;
      downloadLink.style.display = 'none';
    };

    stopBtn.onclick = () => {
      if (recorder && recorder.state !== "inactive") {
        recorder.stop();
      }
      startBtn.disabled = false;
      stopBtn.disabled = true;
    };
  </script>
</body>
</html>